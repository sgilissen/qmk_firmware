// Copyright 2023 QMK
// SPDX-License-Identifier: GPL-2.0-or-later

#include QMK_KEYBOARD_H

enum layers {
	_BASE,
	_NUMS,
	_ASEPRT,
	_MEDIA,
	_MACRO
};

enum keycodes {
	KC_CYCLE_LAYERS = QK_USER,
};

// 1st layer on the cycle
#define LAYER_CYCLE_START 0
// Last layer on the cycle
#define LAYER_CYCLE_END 4

// Add the behaviour of this new keycode
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
    case KC_CYCLE_LAYERS:
      // Our logic will happen on presses, nothing is done on releases
      if (!record->event.pressed) { 
        // We've already handled the keycode (doing nothing), let QMK know so no further code is run unnecessarily
        return false;
      }

      uint8_t current_layer = get_highest_layer(layer_state);

      // Check if we are within the range, if not quit
      if (current_layer > LAYER_CYCLE_END || current_layer < LAYER_CYCLE_START) {
        return false;
      }

      uint8_t next_layer = current_layer + 1;
      if (next_layer > LAYER_CYCLE_END) {
          next_layer = LAYER_CYCLE_START;
      }
      layer_move(next_layer);
      return false;

    // Process other keycodes normally
    default:
      return true;
  }
}


const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    /*
     * ┌───┬───┬───┬───┬───┐
     * │Ins│PUp│Hme│AUp│End│  (ENCODER)
     * ├───┼───┼───┼───┼───┤
     * │Del│PDn│ALf│ADn│Art│   (DUMMY)
     * └───┴───┴───┴───┴───┘
     */
    [_BASE] = LAYOUT_ortho_2x6(
        KC_INS,    KC_PGUP,  KC_HOME,  KC_UP,    KC_END,    KC_CYCLE_LAYERS,
        KC_DEL,    KC_PGDN,  KC_LEFT,  KC_DOWN,  KC_RIGHT,  KC_NO
    ),
    [_NUMS] = LAYOUT_ortho_2x6(
        KC_1,   KC_2,  KC_3,  KC_4, KC_5, KC_CYCLE_LAYERS,
        KC_6,   KC_7,  KC_8,  KC_9, KC_0, KC_NO
    ),
    [_ASEPRT] = LAYOUT_ortho_2x6(
        KC_M,   KC_B,  KC_E,  KC_I, KC_Z, KC_CYCLE_LAYERS,
        KC_V,   KC_G,  KC_L,  KC_U, KC_D, KC_NO
    ),
    [_MEDIA] = LAYOUT_ortho_2x6(
        KC_MPRV,   KC_MPLY,  KC_MNXT,   KC_NO,    KC_VOLU, KC_CYCLE_LAYERS,
        KC_WBAK,   KC_WFWD,  KC_NO,     KC_MUTE,  KC_VOLD, KC_NO
    ),
    [_MACRO] = LAYOUT_ortho_2x6(
        DM_REC1,   DM_REC2,  KC_NO,  KC_NO, DM_RSTP, KC_CYCLE_LAYERS,
        DM_PLY1,   DM_PLY2,  KC_NO,  KC_NO, KC_NO,   KC_NO
    ),

};


#ifdef OLED_ENABLE
static void render_logo(void) {
    static const char PROGMEM my_logo[] = {
    // 'huoran', 32x128px
    0x00, 0x00, 0x10, 0xaa, 0x01, 0xc0, 0x09, 0x55, 0x07, 0x60, 0x02, 0xaa, 0x04, 0x38, 0x03, 0x55, 
    0x0c, 0x0d, 0x16, 0xaa, 0x38, 0x06, 0xa5, 0x55, 0x68, 0x04, 0x86, 0xaa, 0x40, 0x00, 0x85, 0x55, 
    0x40, 0x00, 0x86, 0xaa, 0x7f, 0xff, 0x85, 0x55, 0x00, 0x00, 0x06, 0xaa, 0x00, 0x00, 0x03, 0x55, 
    0x00, 0x00, 0x02, 0xaa, 0x00, 0x00, 0x05, 0x55, 0x00, 0x00, 0x08, 0xaa, 0x00, 0x00, 0x00, 0xd5, 
    0x18, 0xc0, 0x00, 0x6a, 0x25, 0x20, 0x00, 0x35, 0x42, 0x10, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x41, 
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 
    0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
    0x00, 0x1e, 0xf8, 0x00, 0x00, 0x3d, 0x7c, 0x00, 0x00, 0x7a, 0xbe, 0x00, 0x00, 0xf5, 0x5f, 0x00, 
    0x01, 0xea, 0xaf, 0x80, 0x03, 0xd5, 0x57, 0xc0, 0x07, 0xaa, 0xab, 0xe0, 0x2f, 0xff, 0xff, 0xf0, 
    0x4f, 0xff, 0xff, 0xf0, 0x27, 0xff, 0xff, 0xe0, 0x13, 0x80, 0x03, 0xc0, 0x23, 0xc0, 0x07, 0xc0, 
    0x43, 0xff, 0xff, 0xc0, 0x23, 0xff, 0xff, 0xc0, 0x53, 0xff, 0xff, 0xc0, 0x73, 0xff, 0xff, 0xc0, 
    0x73, 0xff, 0xff, 0xc0, 0x73, 0xff, 0xff, 0xc0, 0x73, 0xe0, 0x07, 0xc0, 0x73, 0xef, 0xf7, 0xc0, 
    0x73, 0xef, 0xd7, 0xc0, 0x73, 0xef, 0xf7, 0xc0, 0x7f, 0xef, 0xf7, 0xc0, 0x7f, 0xef, 0xf7, 0xc0, 
    0x7f, 0xef, 0xf7, 0xc0, 0x7f, 0xe0, 0x07, 0xc0, 0x03, 0xff, 0xff, 0xc0, 0x03, 0xe0, 0x07, 0xc0, 
    0x03, 0xf0, 0x0f, 0xc0, 0x03, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xe0, 0x03, 0x81, 0x81, 0xf0, 
    0x03, 0xbd, 0xbd, 0xf8, 0x03, 0xb5, 0xb5, 0xfc, 0x03, 0xbd, 0xbd, 0xfe, 0x03, 0xbd, 0xbd, 0xc0, 
    0x03, 0x81, 0x81, 0xc0, 0x03, 0xff, 0xff, 0xc0, 0x03, 0x81, 0x81, 0xc0, 0x03, 0xc3, 0xc3, 0xc0, 
    0x02, 0xff, 0xff, 0x40, 0x02, 0x7e, 0x7e, 0x40, 0x02, 0x00, 0x00, 0x40, 0x03, 0xbf, 0xfd, 0xc0, 
    0x03, 0xbf, 0xfd, 0xc0, 0x03, 0xbf, 0xfd, 0xc0, 0x03, 0xbf, 0xfd, 0xc0, 0x03, 0xb8, 0x1d, 0xc0, 
    0x03, 0xbb, 0xdd, 0xc0, 0x03, 0xbb, 0x5d, 0xc0, 0x03, 0xbb, 0xdd, 0xc0, 0x03, 0xbb, 0xdd, 0xc0, 
    0x03, 0xbb, 0xdd, 0xc0, 0x03, 0xbb, 0xdd, 0xc0, 0x03, 0xbb, 0xdd, 0xc0, 0x03, 0xbb, 0xdd, 0xc0, 
    0x03, 0xbb, 0xdd, 0xc0, 0x03, 0xb8, 0x1d, 0xc0, 0x03, 0xba, 0x9d, 0xc0, 0x03, 0xb9, 0x5d, 0xc0, 
    0x03, 0xba, 0x9d, 0xc4, 0x23, 0xb9, 0x5d, 0xca, 0x53, 0xba, 0x9d, 0xc4, 0x23, 0xb9, 0x5d, 0xc4, 
    0x23, 0xba, 0x9d, 0xc4, 0x23, 0xb9, 0x5d, 0xd4, 0x23, 0xba, 0x9d, 0xec, 0x23, 0xb9, 0x5d, 0xd4, 
    0x23, 0xba, 0x9d, 0xd4, 0x53, 0xb9, 0x5d, 0xd5, 0xa0, 0x00, 0x00, 0x0a, 0x55, 0x55, 0x55, 0x55, 
    0xaa, 0xaf, 0xea, 0xaa, 0x55, 0x54, 0x35, 0x55, 0x00, 0x07, 0xe0, 0x00, 0x10, 0x04, 0x22, 0x00, 
    0x7c, 0xa7, 0xe3, 0xca, 0x55, 0x14, 0x24, 0x48, 0x10, 0x47, 0xea, 0xbe, 0x7c, 0xa4, 0x25, 0x08, 
    0x11, 0x17, 0xe2, 0x14, 0x39, 0xf4, 0x24, 0x22, 0x10, 0x07, 0xe0, 0x00, 0x7d, 0xf4, 0x20, 0x00, 
    0x01, 0x17, 0xe2, 0xa8, 0x7d, 0x14, 0x24, 0x54, 0x45, 0x17, 0xe8, 0x2a, 0x7d, 0xf4, 0x20, 0x00, 
    0x00, 0x07, 0xea, 0xaa, 0x55, 0x54, 0x35, 0x55, 0xaa, 0xaf, 0xea, 0xaa, 0x55, 0x54, 0x35, 0x55
    };
    
    oled_write_raw_P((my_logo), sizeof(my_logo));
}

bool oled_task_user(void) {
    // Layer graphics
    render_logo();
    /*
    switch (get_highest_layer(layer_state)) {
        case _BASE:
            //oled_write_P(PSTR("Default\n"), false);
            render_logo();
	    break;
        case _NUMS:
            //oled_write_P(PSTR("Numbers\n"), false);
            //oled_write_P(oled_numbers, sizeof(oled_numbers));
            break;
        case _ASEPRT:
            //oled_write_P(PSTR("Aseprite\n"), false);
	    //oled_write_P(oled_aseprite, sizeof(oled_aseprite));
            break;
        case _MEDIA:
            //oled_write_P(PSTR("Media\n"), false);
	    //oled_write_P(oled_media, sizeof(oled_media));
            break;
        case _MACRO:
            //oled_write_P(PSTR("Macro Controls\n"), false);
	    //oled_write_P(oled_macro, sizeof(oled_macro));
            break;
        default:
            // Or use the write_ln shortcut over adding '\n' to the end of your string
            //oled_write_ln_P(PSTR("NoctPad"), false);
    }

    // Host Keyboard LED Status
    // oled_set_cursor(0, 16);
    // led_t led_state = host_keyboard_led_state();
    // oled_write_P(led_state.num_lock ? PSTR("NUM ") : PSTR("    "), false);
    // oled_write_P(led_state.caps_lock ? PSTR("CAP ") : PSTR("    "), false);
    // oled_write_P(led_state.scroll_lock ? PSTR("SCR ") : PSTR("    "), false);
*/
    return false;
}
#endif

#if defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [_BASE] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU) },
    [_NUMS] = { ENCODER_CCW_CW(KC_LEFT, KC_RIGHT) },
    [_ASEPRT] = { ENCODER_CCW_CW(KC_LEFT, KC_RIGHT) },
    [_MEDIA] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU) },
    [_MACRO] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU) },
};
#endif
